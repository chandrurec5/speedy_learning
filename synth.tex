\section{Synthesis of New algorithms}
\subsection{Instances of Bad Design}
To illustrate the usefulness of the ODE based framework, consider the following RL algorithm called SQLFA which combines SQL and function approximation for the purpose of on-policy evaluation:
\begin{align}\label{sqlfa}
\begin{split}
&\theta_{t+1}=\theta_t+\phi(s_t)^\top \alpha_t\big(R(s_t,a_t)+\gamma \phi(s_{t+1})\theta_{t-1}\\&-\phi(s_t)\theta_t +(1-\alpha_t)(\gamma \phi(s_{t+1})\theta_t-\gamma \phi(s_{t+1})\theta_{t-1}\big)
\end{split}
\end{align}
The ODE corresponding to SQLFA is given by
\begin{align}
\begin{split}
&\dot{\theta}(t)=(b_\pi-A_\pi\theta_t)+\gamma\Phi^\top D_\pi P_\pi\Phi^\top\dot{\theta}(t)\\
&\dot{\theta}(t)=(I-\gamma\Phi^\top D_\pi P_\pi\Phi)^{-1}(b_\pi-A_\pi\theta_t)
\end{split}
\end{align}

\begin{align}
\begin{split}
\theta_t&=\theta_t+\alpha_t(y_t-\phi(s_t)^\top(\phi(s_t)\theta_t-\gamma \phi(s_{t+1})\theta_t))\\
y_{t+1}&=y_{t}+\alpha_t(\delta_t)
\end{split}
\end{align}
The design corresponding to the above is given by $g_3=\begin{bmatrix}0\\ b_\pi\end{bmatrix}$, and $H_3=\begin{bmatrix} -A_\pi & I \\ -A_\pi & 0\end{bmatrix}$. The Eigen values of this design can be found by solving the following equations
\begin{align}
|\Lambda I-H|=\begin{bmatrix} \Lambda+A_\pi & -I \\ A_\pi & \Lambda\end{bmatrix}=(\Lambda+A_\pi)\Lambda+A_\pi=0
\end{align}
Thus if $\mu$ is a real Eigen value of $A_\pi$ and $\mu’_{1,2}$ corresponding Eigen values of $H_3$, we have the relation
\begin{align}
\mu’_{i}=\frac{\mu\pm\sqrt{\mu^2-4\mu}}{2}, i=1,2
\end{align}
Notice that for small values of $\mu$, $\mu’_i, i=1,2$ have imaginary parts and the real part is $\mu/2$. Thus this new scheme will be oscillatory (due to imaginary parts) and have poor convergence compared to \tdo since the real part gets divided by a factor of $2$.
\subsection{Instances of Good Design}
We mentioned that the linear update rule in \eqref{linearrec} is an Euler discretization of the ODE in \eqref{linearode}. However, there are different ways to discretize a given ODE and the \emph{Predictor-Corrector} discretization of the \eqref{linearode} is the following update rule
\begin{align}
x^m_{t}&=x_t+\alpha_t(g-Hx_t)\\
x_{t+1}&=x_t+\alpha_t(g-Hx^m_t)
\end{align} 
The idea behind the PC method is to first take a step in the gradient direction to produce a new point $x^m_t$, and then obtain the estimate of the gradient at $x^m_t$ to be used to update $x_t$. It is clear that the GTD-MP is using the PC type update. Notice that the PC updates can be unfurled and written as the following single recursion
\begin{align}
x_{t+1}&=x_t+\alpha_t(g-H(x_t+\alpha_t(g-Hx_t)))\\
&=x_t+\alpha_t(g+\alpha_t g- H +\alpha_t H^2)x_t \\
&= (I-\alpha_t H+\alpha_t^2 H^2)x_t+\alpha_t(g-\alpha_t H g)
\end{align}
The above recursion corresponds to the design $\{g_4,H_4\}$, where $g_4=g-\alpha Hg$, $H_4=H-\alpha H^2$. Notice that the PC method can be slower than the Euler discretization in \eqref{linearrec}. This is due to the fact that if $\mu$ was the smallest Eigen value of $H$, then the smallest Eigen value of $H_4$ will be $\mu-\alpha \mu^2<\mu$.\par
We now present a novel stable algorithm by modifying the PC type updates. We call this the Stable PC update rule and it is given by
\begin{align}\label{spa}
x^m_{t}&=x_t-\beta(g-Hx_t)\\
x_{t+1}&=x_t+\alpha(g-Hx^m_t)
\end{align} 
The unfurled version of the SPC is given below:
\begin{align}\label{}
x_{t+1}= (I-\alpha H-\alpha\beta H^2)x_t+\alpha_t(g+\beta H g)
\end{align}
The design of the SPC is given by $\{g_5,H_5\}$ where $g_5=(g+\beta H g)$ and $H_5=H+\beta H^2$. Now even when all the Eigen values of $H$ do not have positive real parts, we know that Eigen values of $H^2$ are always positive and by choosing an appropriate $\beta>0$ we can ensure that all the Eigen values of $H_5$ have positive real parts.
